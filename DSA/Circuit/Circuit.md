# 题目描述

给定n个64位的二进制数{$a_i$},对第i个位置，求出满足j$\in$[i-k-1,i+k+1]$\cap$[0,n-1]且使得a[i]^a[j]最大。

## 所使用数据结构与算法的构思、原理和实现要点

本题求一定范围内当前二进制数的最大的异或对。由于异或的性质，当前二进制数某位取0时，另一数的对应位取1才可使异或结果最大，反之亦然。因此，可以用一个01trie树来存储这些01串，它具有这些功能：插入一个数；删除一个数；查询与给定的数字异或值最大的数；

插入一个数时，从高位到低位遍历它的所有bit，从根节点开始，如果是0则向左走，如果是1则向右走。最后把下标存在叶子结点中。每个叶子结点其实对应了一个链表（队列），按从小到大的顺序存储对应01串的下标，支持O(1)时间内访问头、插入尾、删除头。这是因为，有多个一样的01串时，需要输出最靠前的那个下标。

删除一个数时，有两种情况。第一种情况是删除之后该数的叶子结点对应的队列不为空，则直接删除队列头即可；第二种情况是删除之后为空，则需要将对应的路径做特殊标记，表示这个数已经不在trie树中。具体来说，从叶子结点向上，将其父节点指向它的下标取相反数。因此插入一个数时还应考虑节点被删除的情况：如果下标为负，则取其相反数；

查询与给定数字异或值最大的数时，首先要确定当前trie树中只存有对应范围内的所有数。这通过插入和删除来实现。其次如何求解这个最值问题呢？不难想到用贪心法。一个数的高位权重更大，所以从高位往低位，依次从根节点向下尽可能选择相反的0/1。如果不存在这样的相反的节点，则只好取相同的节点继续向下重复此过程。这样即可得到与当前数异或值最大的数的下标。

## 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料

1. trie树应该开多大size？

考虑上界，一共n个数，每个数64位，每个节点有01两个分叉，需要n*64*2个int。本题512MB大致够用了。

2. 第13个点TLE

猜想很可能是某个地方修改错误造成了死循环。

3. 参考资料

第三次习题课以及答疑

## 时间和空间复杂度的估算
时间复杂度 O(n)
空间复杂度 O(n)