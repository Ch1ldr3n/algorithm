# 2-4-2 Kidd

## 数据结构和算法设计

**1. 思路**

需要实现查询和更新两种操作。查询操作返回区间内所有元素之和，更新操作使区间内所有元素+1，初始状态所有元素均为0。区间均为闭区间 -> 使用线段树

区间查询，区间修改而不能转化成单点修改 -> 使用懒标记

点的规模达 2^31-1，无法为每个单点单独创造一个存储空间 -> 数据离散化，且线段树的叶子结点代表区间而不是单点

**2 .算法和数据结构设计**

注意到本题n范围极大，因此在构建线段树之前，需要先把所有的询问/更新操作对应的区间端点值储存下来。排序去重之后，得到新的数组。将这些离散的点，和这些点隔开的区间作为叶子节点来构建线段树。从最大的区间开始，递归构造其左儿子区间和右儿子区间，递归的终结条件是遇到叶子节点。

对于线段树的每个结点，维护4个数据：左端点，右端点，区间元素的和，懒惰标记。为使用懒惰标记设计了一个pushdown函数，如果有懒惰标记，更新其左右儿子，同时消除懒惰标记。

修改区间时，从根节点开始递归地修改左儿子和右儿子；直到当前节点的区间包含于该区间。

查询区间时，同样从根节点开始，递归地查询左儿子和右儿子，直到当前节点的区间包含于该区间。

## 完成过程中遇到的问题

1.  如何构建线段树？

因为本题n的范围极大，直接将每个点当成叶子节点显然不可行。只能将点集分组，再将每组作为叶子节点。那么如何实现呢？首先肯定要用递归，其次因为是真二叉树，每次最多只能有两个分支。所以每次分为两个儿子区间，或者是左开右闭区间，或者是闭区间。再分别分类讨论，最后找出终止条件即可。

【参考资料】

OI Wiki - 线段树

## 时空复杂度的估算

1. 时间复杂度

   快速排序：O(mlogm)

   去重：O(m)

   构建线段树：O(m)

   查询和更新：O(logm)

2. 空间复杂度

   线段树占用的空间，O(m)