# 实验报告

## AVL

AVL树是自平衡树的一种。在一个AVL树中，任何节点的两个子树的高度之差不超过1. 每当这个差超过1时，为了维持这个特性，AVL树会自动进行重平衡。对于一有n个节点的AVL树，它的树高总是O(logn)的，因此插入、删除、查询的时间复杂度在平均情况和最坏情况下均为O(logn).

**关于重平衡**  为了保持AVL树的性质，在插入和删除之后，可能需要1或多次的旋转。

1.  左左情况：右旋左儿子
2.  右右情况：左旋右儿子
3.  左右情况：左旋左儿子+右旋新的左儿子
4.  右左情况：右旋右儿子+左旋新的右儿子

插入或者删除操作时，将操作的节点到根节点的路径上所有不平衡的节点按照所描述的4种简单情况旋转后，即可重新平衡。

## Splay

在一个splay树中，最后访问的节点(key)总是在树的根部。通过zig和zag操作，将每次访问的节点旋转至根部。具体来说，查询时，将对应key的节点移动到树根，如果树中不存在这个key，则将最后访问的树叶节点移动到树根；插入时，将新插入的节点移动到树根；删除时，先将对应的节点移到树根，再进行相应操作。

对于同时有父节点和祖父节点的节点，可以分为如下两种情况：

1.  zig-zig和zag-zag：儿子节点和父亲节点均为左孩子或者均为右孩子，则先将父节点上浮，再将子节点上浮。
2.  zig-zag和zag-zig：子节点和父节点一个为左孩子一个为右孩子，则将子节点连续上浮两次。

于是，我们即可将最近访问的节点旋转到树根。这样也会让树更加平衡：对于n个节点的splay树，它的树高总是O(logn)的。因此，插入、删除、查询的时间复杂度均为O(logn)。



## 设计测例

**思路** splay善于处理这样的情况：所有操作对象集中分布在数据库所有元素集合中的一个子集中。因此，设计两组数据。第一组是随机数据，所有数据分布较为均衡；第二组为特殊构造的数据，如果上一次操作的key为lastKey, 则本次操作选取的key为[lastKey - delta, lastKey + delta]范围内；如果随机出来的key不合法，则重新在所有合法范围内随机。

**实现** 第一组数据，用srand(time(0))和rand()来控制随机和对应操作的比例；第二组数据，增加一个保存上一次访问的key的信息的变量，以便本次随机时，数据集中落在以上次的key为中心点的小区间内。需要注意的是，随机出来的数据可能不合法，比如删除的key可能不在树中，因此我用一个很大的数组把所有插入过的key都存起来，在选择要删除的key时从这个数组中随机选取；比如随机到了重复的插入key，这时用while循环控制直到随机到不同的key才退出循环。

第一组数据存储到$in1\_0.txt-in1\_9.txt$之中，第二组数据存储在$in2\_0.txt - in2\_9.txt$之中。对这两组数据，都有查询、插入、删除的比例大致为6:3:1.

## 测试结果

测试环境：

windows，gcc version 8.3.0

测试方法：

每组数据对splay树和avl树分别做十次测试取平均。

测试结果：

testResult.txt

![image-20210528170241939](./image-20210528170241939.png)

结论：

对于splay树，集中数据的处理速度是分散数据的处理速度的$\frac{7927.3}{46.2}=171.6$倍；

对于AVL树，集中数据的处理速度是分散数据的处理速度的$\frac{8212.9}{91.9}=89.4$倍。

因此，splay树在处理集中的数据集时，性能更加优越。原因是splay树每次访问一个节点时都将其移动到树根，于是之后访问这个离这个节点的key较近的节点时， 深度大大减小，时间复杂度在平均情况下有很大的优化。

而AVL树在处理大量、分散数据时性能更加优越。但由于生成测例时数据量选择的不够大，还不足以体现出AVL在处理大量分散数据时比splay树快的特性。