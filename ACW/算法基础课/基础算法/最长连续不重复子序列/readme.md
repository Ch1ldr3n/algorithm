# 双指针算法

核心思想：降低时间复杂度  $O(n^2)\rightarrow O(n)$

```
for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j)
        do sth...
    
```

```
模板 （注意i是右端点）
for (int i = 0, j = 0; i < n; ++i) {
    while (j < i && check(i, j)) j++;
    do sth...
}
```

# 最长不重复子序列

$9,3,6,9,5,10,1,2,3,9$

暴力的做法：枚举所有区间$[j,i]$，如果没有重复元素，更新$res$

**优化**：

枚举两个端点$\rightarrow$枚举一个端点，另一个端点用算法来控制。

因此，用$i$来维护区间的右端点，`for(int i=0;i<n;++i)`

对于每一个$i$，$j$维护使得$[j,i]$没有重复元素的最小的$j$

可以发现，当$i$每次向右移动时，$j$是不可能向左移动的。假设上一轮循环中，区间是$[j_1,i]$，这一轮维护的区间是$[j_2,i+1]$。假设$j_2<j_1$，则$[j_2,i]$也没有重复元素，那么上一轮维护的区间就应该是$[j_2,i]$，矛盾。因此，j要么不动，要么向右移动（当新加入区间的$a[i]$与前面元素重复时）

**要注意学习这种动态维护区间的方法**