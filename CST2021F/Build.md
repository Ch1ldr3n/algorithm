# 2-1 Build

## 数据结构和算法设计

**1. 思路**

本题主要有两个步骤，一个是多叉树的构建，一个是多叉树的子树移动。只是需要用路径序列来代替节点序号。对于多叉树构建，输入邻接表，容易得到一个在O(n)时间内找到子节点，在O(1)时间内找到父节点的多叉树（讲义“树的深度”部分）。

**2 .算法设计**

* 双指针算法：在初始化树的结构时，需要遍历的处理每个结点的孩子序列。在处理孩子序列的前后指针时，通过一前一后的两个指针来实现。

* 递归算法：在初始化树的结构时，通过递归来不断更新多叉树每个结点的size和height属性。
* 其他主要是对多叉树属性的维护。

**3. 数据结构设计**

用多个数组来存储多叉树，数组下标代表节点序号，不同数组存储该节点不同的属性。例如，head[i]代表第i号节点的孩子序列的头结点的序号；height[i]代表第i号节点对应的子树的高度。其他属性还有：父节点的序号，孩子序列的尾结点的序号，相邻两个兄弟节点的序号，以及节点i对应的子树的规模。

对于多叉树的删除和插入操作，一次要处理很多节点。所以虽然是用数组存储多叉树，但是是用数组实现链表的思想，其本质仍然是链表，所以插入和删除可以在O(1)时间内完成。不过由于每次移动子树之后，多叉树的某些节点的属性会随之改变，因此复杂度远不止O(1)。

说到移动子树后的更新，一个是对子树规模更新：依次访问子树的父节点和祖先节点，一一更改即可；一个是对子树高度的更新，暴力的做法是遍历其父节点的孩子序列，每个孩子对应一颗子树，然后一一比较判断大小。

## 完成过程中遇到的问题

1. 实现起来过于复杂，很多地方容易写乱写错。比如，因为一个地方的"="错写成了"!="号，找了好久才de出bug。因此，写代码必须要细心，同时合理的规划代码的结构，多用函数和结构体。
2. 子树移动过程中对应节点子树高度的更新。如前所述，遍历的做法时间代价过于昂贵。在助教的启发下，注意到题目中有对于cost的限制，实际上大部分情况下，这些操作都是对树的左半部分位置比较靠前的节点进行的。所以可以维护每个结点的最大后缀高度，即当前节点和所有之后的节点中最大的高度。某节点高度变化时，其后面所有节点的最大后缀高度不变，其前面所有节点可以自底向上的完成更新。通过最大后缀高度加1，就可以得到其父节点的高度。

【参考资料】

第二次PA习题课/答疑课

讲义：二叉树部分

## 时空复杂度的估算

1. 空间复杂度：

   即存储多叉树所用的空间，O(n)

2. 时间复杂度：

   建构多叉树：O(n)

   移动子树：O(1)

   更新高度和规模: O(n)

   总体复杂度估计：O(m * cost)
